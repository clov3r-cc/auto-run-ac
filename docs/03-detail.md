# エアコン自動制御システム 詳細設計

## データモデル詳細

### スケジュールデータ構造

#### デフォルトスケジュール

基本的な帰宅時刻とシステムの有効/無効を管理する。時刻は24時間形式のHH:MM形式で保存し、有効フラグはboolean値で管理する。

#### 特定日スケジュール

日付をキーとして個別の設定を保存する。日付は国際標準のYYYY-MM-DD形式を使用し、帰宅時刻が未設定の場合はデフォルトスケジュールの時刻を継承する。

### 設定データ構造

#### 温度設定

下限20℃、上限28℃で固定とする。この値は環境変数として設定され、変更はアプリケーション側では行わない。

#### システム設定

現在の実装では環境変数で管理されているため、設定用KVは使用していない。将来的にフロントエンドからシステム全体の有効/無効を切り替える場合は、設定用KVの追加を検討する。

### 履歴データ構造

#### 実行履歴

各実行の詳細情報を記録する。実行日時はISO 8601形式で保存し、成功/失敗、実行時温度、目標温度、実行した制御内容（暖房/冷房/制御なし）、エラー情報を含む。

#### システム状態

最終実行時刻、次回実行予定時刻、現在温度、システム有効状態を管理する。これらの情報はダッシュボードでのリアルタイム表示に使用する。

### KVストレージ設計詳細

#### キー命名規則

機能ごとに別々のKVを使用するため、各KV内でのキー設計は以下とする：

**スケジュール用KV（KV\_\_SCHEDULES）：**

- デフォルト設定：`default`
- 特定日設定：日付文字列（YYYY-MM-DD）

**履歴用KV（KV\_\_HISTORY）：**

- 実行日の記録：日付文字列（YYYY-MM-DD）

## フロントエンド詳細設計

### ページ構成

#### ダッシュボードページ

現在温度、システム状態、次回実行予定、最新実行結果を表示する。自動更新機能により最新情報を定期的に取得し、視覚的に分かりやすいカードレイアウトで情報を提示する。

#### スケジュール管理ページ

デフォルトスケジュールと特定日スケジュールを管理する。カレンダーコンポーネントを使用して直感的な日付選択を提供し、設定済みの特別日は視覚的にハイライト表示する。

#### 設定ページ

システム設定を管理する。現在は環境変数での管理のため、設定項目は限定的。将来的にシステム有効/無効切り替えを追加予定。

#### 履歴ページ

実行履歴をテーブル形式で表示し、日付範囲での絞り込み機能を提供する。成功/失敗の視覚的な表示と、エラー詳細の展開表示機能を含む。

### コンポーネント設計

#### 共通UIコンポーネント

再利用可能なボタン、入力フィールド、スイッチ、カード、ローディング、エラーメッセージ、カレンダーコンポーネントを作成する。統一されたデザインシステムに基づく一貫性のあるUI要素を提供する。

#### 機能別コンポーネント

各ページの機能に特化したコンポーネントを作成する。単一責任の原則に従い、テスタブルで保守しやすい構造とする。

## バックエンド詳細設計

### 定期実行処理フロー

#### 実行判定ロジック

15分間隔で実行される定期処理では、以下の順序で判定を行う：

1. 当日の実行済みチェック（重複実行防止）
2. スケジュール設定の取得と有効性確認
3. 温度取得と制御判定
4. 実行タイミングの計算と判定

#### スケジュール優先順位

特定日スケジュールが設定されている場合は、デフォルトスケジュールより優先する。特定日で無効化されている場合は、その日の制御を完全にスキップする。

#### 実行タイミング計算

帰宅時間と現在温度、目標温度の差分を基に、エアコン起動タイミングを動的に計算する。

**計算ロジック：**

1. 現在温度と目標温度（20℃または28℃）の差分を算出
2. 温度変化速度：1時間あたり3度で計算
3. 必要な制御時間を計算
4. 帰宅時刻から必要時間を引いた時刻が起動時刻
5. 現在時刻が起動時刻に達している場合に制御を実行

**例：**

- 現在温度：32℃、目標温度：28℃、帰宅時刻：18:00
- 温度差：4℃、必要時間：2時間
- 起動時刻：18:00 - 2時間 = 16:00

### 温度制御アルゴリズム

#### 制御判定

現在温度が20℃未満または28℃超過で実行する。20℃以上28℃以下の場合は制御を行わない。

#### 目標温度設定

現在温度が20℃未満の時は20℃、28℃以上の時は28℃に固定される。段階的な調整は行わず、一度の制御で目標温度まで調整する。

### SwitchBot API連携

#### API呼び出し設計

温度取得と制御コマンド送信の2つの主要APIを使用する。認証はトークンとクライアントシークレットで行い、デバイスIDを指定してコマンドを送信する。

#### エラーハンドリング

API呼び出し失敗時の再試行は実装せず、エラーログを出力して処理を終了する。

### 結果記録・通知

#### 履歴保存

制御実行成功時は実行日をKVに記録し、翌日以降の重複実行を防ぐ。

#### Discord通知

制御実行成功時のみDiscord Webhookを使用して通知を送信する。通知内容は実行時刻、現在温度、目標温度を含む。エラー時の通知は行わない。

## セキュリティ設計

### 認証・認可

#### フロントエンド認証

個人利用を前提としているため、複雑な認証システムは実装しない。Cloudflare Pagesのアクセス制御機能を活用して、特定のユーザーのみアクセス可能とする。

### 入力値検証

#### フロントエンド検証

ユーザー入力値は送信前にクライアント側で検証する。時刻形式、必須項目の妥当性をチェックし、不正な値の送信を防ぐ。

#### バックエンド検証

Workers側でも受信データの検証を実行し、KVに不正なデータが保存されることを防ぐ。特に時刻形式の検証を重視する。

### 環境変数管理

#### 秘匿情報の分離

SwitchBotトークン、Discord Webhook URLなどの機密情報は環境変数として管理し、コードに直接記述しない。Cloudflareの環境変数機能を使用して安全に管理する。

## 運用設計

### 監視・ログ

#### 実行ログ

Workers実行時のログは自動的に記録され、Cloudflareダッシュボードで確認可能とする。エラー時の詳細情報も含める。

### メンテナンス

#### データクリーンアップ

履歴データは3日前以前のデータを自動削除する。スケジュールデータも過去の特定日設定は定期的に削除してKVストレージ容量を管理する。

### パフォーマンス

#### KVアクセス最適化

頻繁にアクセスするデータの読み書き回数を最小限に抑える。特に重複実行チェックの効率化を図る。

#### フロントエンド最適化

必要なデータのみを取得し、不要な再レンダリングを避ける。ローディング状態の適切な表示により、ユーザー体験を向上させる。
